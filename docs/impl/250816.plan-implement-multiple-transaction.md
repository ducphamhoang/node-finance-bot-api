### Implementing Multi-Transaction Extraction

Your primary goal is to handle multiple transactions in a single input. This requires changes from the AI core up to the user interface. Hereâ€™s a step-by-step plan to achieve this.

#### Step 1: Update the AI Flow and Schemas

The heart of the change is in your Genkit flow. The AI model needs to be instructed to find *all* transactions and the output schema must be updated to expect an array of objects.

**File:** `src/ai/flows/extract-transaction-details.ts`

1.  **Rename the Output Schema**: To avoid confusion, let's rename the existing `ExtractTransactionDetailsOutputSchema` to `SingleTransactionSchema`, as it represents one transaction.
2.  **Create a New Array-Based Output Schema**: The flow's output will now be an array of `SingleTransactionSchema`.
3.  **Update the Prompt**: The prompt needs to be explicitly told to look for multiple transactions and return a JSON array.

```typescript
// src/ai/flows/extract-transaction-details.ts
'use server';

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

// ... (InputSchema remains the same)
export type ExtractTransactionDetailsInput = z.infer<typeof ExtractTransactionDetailsInputSchema>;

// 1. RENAME the schema for a single transaction
const SingleTransactionSchema = z.object({
  description: z.string().describe('The description of the transaction.'),
  category: z.string().nullable().describe('The category of the transaction.'),
  type: z.string().describe('The type of transaction (e.g., income, expense).'),
  amount: z.number().nullable().describe('The amount of the transaction.'),
  date: z.string().nullable().describe('The date of the transaction in ISO format (YYYY-MM-DD).'),
});

// 2. DEFINE the new output schema as an array of the single transaction schema
const ExtractTransactionDetailsOutputSchema = z.array(SingleTransactionSchema);
export type ExtractTransactionDetailsOutput = z.infer<typeof ExtractTransactionDetailsOutputSchema>;

// ... (AssignNullTool remains the same)

export async function extractTransactionDetails(input: ExtractTransactionDetailsInput): Promise<ExtractTransactionDetailsOutput> {
  return extractTransactionDetailsFlow(input);
}

const prompt = ai.definePrompt({
  name: 'extractTransactionDetailsPrompt',
  input: {schema: ExtractTransactionDetailsInputSchema},
  // 3. UPDATE the prompt to expect the new array-based output schema
  output: {schema: ExtractTransactionDetailsOutputSchema},
  tools: [AssignNullTool],
  // 4. REWRITE the prompt to handle multiple transactions
  prompt: `You are an AI assistant that extracts key details from financial transaction descriptions.
  
  Identify all distinct financial transactions in the provided text. For each transaction, extract the following information:
  - description: A concise description of the transaction.
  - category: The category of the transaction (e.g., groceries, dining, utilities).
  - type: The type of transaction (income or expense).
  - amount: The numerical amount of the transaction.
  - date: The date of the transaction in ISO format (YYYY-MM-DD).

  If you cannot determine a value for 'category', 'amount', or 'date' for a specific transaction and omnibusMode is enabled, use the assignNull tool for that field.

  Here is the transaction description:
  {{text}}

  Return the extracted information as a JSON array of objects. Each object in the array should represent a single transaction. If no transactions are found, return an empty array.
  `,
});

const extractTransactionDetailsFlow = ai.defineFlow(
  {
    name: 'extractTransactionDetailsFlow',
    inputSchema: ExtractTransactionDetailsInputSchema,
    outputSchema: ExtractTransactionDetailsOutputSchema,
  },
  async input => {
    // The task-specific modes don't make as much sense for multiple transactions.
    // You could either remove this logic or adapt it to apply to each transaction found.
    // For now, we'll simplify and just get the direct output.
    const { output } = await prompt(input);
    return output || []; // Return the array or an empty array if null
  }
);
```

#### Step 2: Update the Server Action

Your server action in `actions.ts` now needs to handle the new array-based output type.

**File:** `src/app/actions.ts`

```typescript
// src/app/actions.ts
'use server';

import {
  extractTransactionDetails,
  type ExtractTransactionDetailsInput,
  type ExtractTransactionDetailsOutput, // This is now an array type
} from '@/ai/flows/extract-transaction-details';

export type ActionResult = {
  error?: string;
  // The data property can now be an array of transactions
  data?: ExtractTransactionDetailsOutput | null;
};

export async function getTransactionDetails(
  input: ExtractTransactionDetailsInput
): Promise<ActionResult> {
  try {
    const result = await extractTransactionDetails(input);
    return { data: result };
  } catch (e: any) {
    console.error('Error in getTransactionDetails action:', e);
    return { error: e.message || 'An unexpected error occurred.' };
  }
}
```

#### Step 3: Update the Frontend Component

The `FinanceFlow` component must be updated to store and render a list of results instead of a single result object.

**File:** `src/components/finance-flow.tsx`

```tsx
// src/components/finance-flow.tsx
'use client';

import { useState } from 'react';
// ... other imports

// This type is now an array of transaction objects
import type { ExtractTransactionDetailsOutput } from '@/ai/flows/extract-transaction-details';
// ... other imports

// ... (ResultItem and ResultSkeleton are fine as they are, we'll just loop them)

export function FinanceFlow() {
  const [text, setText] = useState('');
  const [task, setTask] = useState<TaskType>('full');
  const [omnibusMode, setOmnibusMode] = useState(true);
  const [loading, setLoading] = useState(false);
  
  // 1. UPDATE state to hold an array of results
  const [results, setResults] = useState<ExtractTransactionDetailsOutput | null>(null);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    if (!text.trim()) {
      setError('Please enter some text to analyze.');
      return;
    }
    setLoading(true);
    setError(null);
    setResults(null); // Clear previous results

    const actionResult: ActionResult = await getTransactionDetails({
      text,
      // Task-specific logic is less relevant now, you might want to remove it from the UI
      task: task === 'full' ? undefined : task,
      omnibusMode,
    });

    if (actionResult.error) {
      setError(actionResult.error);
    } else if (actionResult.data) {
      setResults(actionResult.data); // Set the array of results
    }

    setLoading(false);
  };
  
  // ... (getTaskDescription is fine)

  return (
    <div className="grid grid-cols-1 gap-8 md:grid-cols-2">
      {/* --- The Form Card (no changes needed here) --- */}
      <Card /* ... */ >
        {/* ... */}
      </Card>
      
      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Extracted Details</CardTitle>
          <CardDescription>
            {/* 2. UPDATE description based on results array */}
            {results ? `Found ${results.length} transaction(s).` : 'Results from the AI analysis will appear here.'}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {error && ( /* ... Error alert is fine */ )}

          {loading && ( /* ... Loading skeleton is fine */ )}

          {/* 3. UPDATE rendering logic to map over the results array */}
          {results && !loading && (
            <div className="space-y-6 animate-in fade-in-50 duration-500">
              {results.map((result, index) => (
                <div key={index} className="space-y-4 rounded-lg border p-4">
                  <h3 className="font-semibold text-lg">Transaction #{index + 1}</h3>
                  <ResultItem icon={<FileText size={20} />} label="Description" value={result.description} />
                  <ResultItem icon={<Tag size={20} />} label="Category" value={result.category} />
                  <ResultItem icon={<ArrowRightLeft size={20} />} label="Type" value={result.type} />
                  <ResultItem icon={<CircleDollarSign size={20} />} label="Amount" value={result.amount} />
                  <ResultItem icon={<Calendar size={20} />} label="Date" value={result.date} />
                </div>
              ))}
            </div>
          )}

           {/* 4. UPDATE the initial empty state message */}
           {!loading && !results && !error && (
             <div /* ... */ >
                <Sparkles className="h-10 w-10 mb-4" />
                <p>Your results are waiting to be discovered.</p>
                <p className="text-sm">Enter one or more transactions and click "Process".</p>
             </div>
           )}
        </CardContent>
      </Card>
    </div>
  );
}
```