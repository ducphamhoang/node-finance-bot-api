'use server';

/**
 * @fileOverview Transaction detail extraction AI agent.
 *
 * - extractTransactionDetails - A function that handles the transaction detail extraction process.
 * - ExtractTransactionDetailsInput - The input type for the extractTransactionDetails function.
 * - ExtractTransactionDetailsOutput - The return type for the extractTransactionDetails function.
 */

import { z } from 'zod';
import { llmClient } from '@/ai/llm';
import { buildExtractTransactionDetailsMessages } from '@/ai/prompts/extract-transaction-details';
import { getLoggingService, generateSessionId } from '@/lib/logging';

const ExtractTransactionDetailsInputSchema = z.object({
  text: z
    .string()
    .describe('A description of financial transaction(s).'),
  task: z.enum(['categorize', 'get_transaction_type', 'get_amount']).optional().describe('Specific task to perform (optional).'),
  omnibusMode: z.boolean().optional().describe('Whether to intelligently assign null values when values cannot be reasonably inferred.')
});
export type ExtractTransactionDetailsInput = z.infer<typeof ExtractTransactionDetailsInputSchema>;

// Rename the schema for a single transaction
const SingleTransactionSchema = z.object({
  description: z.string().describe('The description of the transaction.'),
  category: z.string().nullable().describe('The category of the transaction.'),
  type: z.string().describe('The type of transaction (e.g., income, expense).'),
  amount: z.number().nullable().describe('The amount of the transaction.'),
  date: z.string().nullable().describe('The date of the transaction in ISO format (YYYY-MM-DD).'),
  merchant: z.string().nullable().describe('The merchant or business name associated with the transaction.'),
  paymentMethod: z.string().nullable().describe('The payment method used for the transaction (e.g., credit card, cash, debit card, PayPal).'),
  location: z.string().nullable().describe('The location where the transaction took place.'),
  llm_comment: z.string().describe('A funny or witty comment about the transaction generated by the LLM.'),
});

// Define the new output schema as an array of the single transaction schema
const ExtractTransactionDetailsOutputSchema = z.array(SingleTransactionSchema);
export type ExtractTransactionDetailsOutput = z.infer<typeof ExtractTransactionDetailsOutputSchema>;

/**
 * Clean and extract JSON from LLM response that might be wrapped in markdown
 */
function cleanJsonResponse(content: string): string {
  // Remove markdown code blocks if present
  const jsonBlockRegex = /```(?:json)?\s*([\s\S]*?)\s*```/;
  const match = content.match(jsonBlockRegex);
  
  if (match) {
    return match[1].trim();
  }
  
  // If no code blocks found, return the content as-is (might already be clean JSON)
  return content.trim();
}

/**
 * Parse JSON response from LLM and validate against schema
 */
function parseAndValidateResponse(content: string): ExtractTransactionDetailsOutput {
  try {
    // Clean the response to extract JSON from potential markdown wrapping
    const cleanedContent = cleanJsonResponse(content);
    
    // Try to parse the cleaned JSON response
    const parsed = JSON.parse(cleanedContent);

    // Validate against our schema
    const result = ExtractTransactionDetailsOutputSchema.parse(parsed);
    return result;
  } catch (error) {
    console.error('Failed to parse LLM response:', error);
    console.error('Raw response:', content);
    console.error('Cleaned content:', cleanJsonResponse(content));

    // Return empty array if parsing fails
    return [];
  }
}

/**
 * Apply task-specific filtering to transaction results
 */
function applyTaskFiltering(
  transactions: ExtractTransactionDetailsOutput,
  task?: 'categorize' | 'get_transaction_type' | 'get_amount'
): ExtractTransactionDetailsOutput {
  if (!task || transactions.length !== 1) {
    return transactions;
  }

  const transaction = transactions[0];

  switch (task) {
    case 'categorize':
      return [{
        ...transaction,
        type: 'N/A',
        amount: null,
        date: null,
        merchant: null,
        paymentMethod: null,
        location: null
      }];
    case 'get_transaction_type':
      return [{
        ...transaction,
        category: null,
        amount: null,
        date: null,
        merchant: null,
        paymentMethod: null,
        location: null
      }];
    case 'get_amount':
      return [{
        ...transaction,
        category: null,
        type: 'N/A',
        date: null,
        merchant: null,
        paymentMethod: null,
        location: null
      }];
    default:
      return transactions;
  }
}

/**
 * Extract transaction details using the new LLM client
 */
async function extractTransactionDetailsFlow(input: ExtractTransactionDetailsInput): Promise<ExtractTransactionDetailsOutput> {
  const { text, task, omnibusMode } = input;

  try {
    // Build messages using the prompt template
    const messages = buildExtractTransactionDetailsMessages({
      text,
      task,
      omnibusMode,
    });

    // Call the LLM client
    const response = await llmClient.call(messages, {
      temperature: 0.1, // Low temperature for consistent extraction
      maxTokens: 2000,
    });

    // Parse and validate the response
    const transactions = parseAndValidateResponse(response.content);

    // Apply task-specific filtering
    return applyTaskFiltering(transactions, task);
  } catch (error) {
    console.error('Error in extractTransactionDetailsFlow:', error);
    throw error;
  }
}

export async function extractTransactionDetails(input: ExtractTransactionDetailsInput): Promise<ExtractTransactionDetailsOutput> {
  return extractTransactionDetailsFlow(input);
}

/**
 * Enhanced extraction function with logging support
 */
export async function extractTransactionDetailsWithLogging(
  input: ExtractTransactionDetailsInput,
  loggingContext?: {
    userId?: string;
    sessionId?: string;
  }
): Promise<ExtractTransactionDetailsOutput> {
  const startTime = Date.now();
  let response: any = null;
  let provider: string | undefined;
  let model: string | undefined;

  try {
    const { text, task, omnibusMode } = input;

    // Build messages using the prompt template
    const messages = buildExtractTransactionDetailsMessages({
      text,
      task,
      omnibusMode,
    });

    // Call the LLM client with response metadata tracking
    const llmResponse = await llmClient.call(messages, {
      temperature: 0.1, // Low temperature for consistent extraction
      maxTokens: 2000,
    });

    // Extract metadata from response
    provider = llmResponse.metadata?.provider;
    model = llmResponse.metadata?.model;
    response = llmResponse;

    // Parse and validate the response
    const transactions = parseAndValidateResponse(llmResponse.content);

    // Apply task-specific filtering
    const result = applyTaskFiltering(transactions, task);

    // Log the interaction asynchronously (non-blocking)
    const duration = Date.now() - startTime;
    
    // Generate session ID if not provided for anonymous users
    const sessionId = loggingContext?.sessionId || generateSessionId();
    
    // Don't await this to keep it non-blocking
    getLoggingService().logInteraction({
      userId: loggingContext?.userId,
      sessionId,
      input: text,
      response: result,
      metadata: {
        provider,
        model,
        duration,
        tokens: llmResponse.metadata?.tokens,
        cached: llmResponse.metadata?.cached,
      },
    }).catch(error => {
      // Already logged in the service, just ensure it doesn't bubble up
      console.warn('Non-blocking logging error:', error.message);
    });

    return result;
  } catch (error) {
    // Log error interactions as well
    const duration = Date.now() - startTime;
    const sessionId = loggingContext?.sessionId || generateSessionId();

    // Non-blocking error logging
    getLoggingService().logInteraction({
      userId: loggingContext?.userId,
      sessionId,
      input: input.text,
      response: { error: error instanceof Error ? error.message : 'Unknown error' },
      metadata: {
        provider,
        model,
        duration,
        error: true,
      },
    }).catch(() => {
      // Ignore logging errors during error handling
    });

    console.error('Error in extractTransactionDetailsFlow:', error);
    throw error;
  }
}