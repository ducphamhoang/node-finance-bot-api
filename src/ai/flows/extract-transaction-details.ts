'use server';

/**
 * @fileOverview Transaction detail extraction AI agent.
 *
 * - extractTransactionDetails - A function that handles the transaction detail extraction process.
 * - ExtractTransactionDetailsInput - The input type for the extractTransactionDetails function.
 * - ExtractTransactionDetailsOutput - The return type for the extractTransactionDetails function.
 */

import { z } from 'zod';
import { llmClient } from '@/ai/llm';
import { buildExtractTransactionDetailsMessages } from '@/ai/prompts/extract-transaction-details';

const ExtractTransactionDetailsInputSchema = z.object({
  text: z
    .string()
    .describe('A description of financial transaction(s).'),
  task: z.enum(['categorize', 'get_transaction_type', 'get_amount']).optional().describe('Specific task to perform (optional).'),
  omnibusMode: z.boolean().optional().describe('Whether to intelligently assign null values when values cannot be reasonably inferred.')
});
export type ExtractTransactionDetailsInput = z.infer<typeof ExtractTransactionDetailsInputSchema>;

// Rename the schema for a single transaction
const SingleTransactionSchema = z.object({
  description: z.string().describe('The description of the transaction.'),
  category: z.string().nullable().describe('The category of the transaction.'),
  type: z.string().describe('The type of transaction (e.g., income, expense).'),
  amount: z.number().nullable().describe('The amount of the transaction.'),
  date: z.string().nullable().describe('The date of the transaction in ISO format (YYYY-MM-DD).'),
  merchant: z.string().nullable().describe('The merchant or business name associated with the transaction.'),
  paymentMethod: z.string().nullable().describe('The payment method used for the transaction (e.g., credit card, cash, debit card, PayPal).'),
  location: z.string().nullable().describe('The location where the transaction took place.'),
  llm_comment: z.string().describe('A funny or witty comment about the transaction generated by the LLM.'),
});

// Define the new output schema as an array of the single transaction schema
const ExtractTransactionDetailsOutputSchema = z.array(SingleTransactionSchema);
export type ExtractTransactionDetailsOutput = z.infer<typeof ExtractTransactionDetailsOutputSchema>;

/**
 * Clean and extract JSON from LLM response that might be wrapped in markdown
 */
function cleanJsonResponse(content: string): string {
  // Remove markdown code blocks if present
  const jsonBlockRegex = /```(?:json)?\s*([\s\S]*?)\s*```/;
  const match = content.match(jsonBlockRegex);
  
  if (match) {
    return match[1].trim();
  }
  
  // If no code blocks found, return the content as-is (might already be clean JSON)
  return content.trim();
}

/**
 * Parse JSON response from LLM and validate against schema
 */
function parseAndValidateResponse(content: string): ExtractTransactionDetailsOutput {
  try {
    // Clean the response to extract JSON from potential markdown wrapping
    const cleanedContent = cleanJsonResponse(content);
    
    // Try to parse the cleaned JSON response
    const parsed = JSON.parse(cleanedContent);

    // Validate against our schema
    const result = ExtractTransactionDetailsOutputSchema.parse(parsed);
    return result;
  } catch (error) {
    console.error('Failed to parse LLM response:', error);
    console.error('Raw response:', content);
    console.error('Cleaned content:', cleanJsonResponse(content));

    // Return empty array if parsing fails
    return [];
  }
}

/**
 * Apply task-specific filtering to transaction results
 */
function applyTaskFiltering(
  transactions: ExtractTransactionDetailsOutput,
  task?: 'categorize' | 'get_transaction_type' | 'get_amount'
): ExtractTransactionDetailsOutput {
  if (!task || transactions.length !== 1) {
    return transactions;
  }

  const transaction = transactions[0];

  switch (task) {
    case 'categorize':
      return [{
        ...transaction,
        type: 'N/A',
        amount: null,
        date: null,
        merchant: null,
        paymentMethod: null,
        location: null
      }];
    case 'get_transaction_type':
      return [{
        ...transaction,
        category: null,
        amount: null,
        date: null,
        merchant: null,
        paymentMethod: null,
        location: null
      }];
    case 'get_amount':
      return [{
        ...transaction,
        category: null,
        type: 'N/A',
        date: null,
        merchant: null,
        paymentMethod: null,
        location: null
      }];
    default:
      return transactions;
  }
}

/**
 * Extract transaction details using the new LLM client
 */
async function extractTransactionDetailsFlow(input: ExtractTransactionDetailsInput): Promise<ExtractTransactionDetailsOutput> {
  const { text, task, omnibusMode } = input;

  try {
    // Build messages using the prompt template
    const messages = buildExtractTransactionDetailsMessages({
      text,
      task,
      omnibusMode,
    });

    // Call the LLM client
    const response = await llmClient.call(messages, {
      temperature: 0.1, // Low temperature for consistent extraction
      maxTokens: 2000,
    });

    // Parse and validate the response
    const transactions = parseAndValidateResponse(response.content);

    // Apply task-specific filtering
    return applyTaskFiltering(transactions, task);
  } catch (error) {
    console.error('Error in extractTransactionDetailsFlow:', error);
    throw error;
  }
}

export async function extractTransactionDetails(input: ExtractTransactionDetailsInput): Promise<ExtractTransactionDetailsOutput> {
  return extractTransactionDetailsFlow(input);
}